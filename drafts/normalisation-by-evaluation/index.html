<!DOCTYPE HTML><html lang="en"><head><meta charset="utf-8"><meta content="ie=edge" http-equiv="x-ua-compatible"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="../../css/reset.css" rel="stylesheet"><link href="../../css/style.css" rel="stylesheet"><link href="../../css/iosevka.css" rel="stylesheet"><script type="text/x-mathjax-config">MathJax.Hub.Config({  extensions: ["tex2jax.js"],  jax: ["input/TeX","output/HTML-CSS"],  "HTML-CSS": {    styles: {".MathJax_Preview": {visibility: "hidden"}}  }});</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script></head><body><header><h3><a href="../../">colimiting case</a></h3><nav><h4><a href="https://twitter.com/mrkgrnao">twitter</a></h4><h4><a href="https://github.com/mrkgnao">projects</a></h4><h4><a href="../../things-i-like#music">music</a></h4><h4><a href="../../about">about</a></h4></nav></header><main role="main"><title>Real-world type theory implementation I: untyped normalisation by evaluation</title><article><div class="post-header"><div class="post-header__date">February  1, 2020</div><h1 class="post-header__title">Real-world type theory implementation I: untyped normalisation by evaluation</h1><div class="post-header__author">Soham Chowdhury</div></div><section><div style="display:none;">
<p>\[ \DeclareMathOperator{\D}{\mathsf{D}} \DeclareMathOperator{\Dne}{\D^\mathsf{ne}} \DeclareMathOperator{\Dnf}{\D^\mathsf{nf}} \DeclareMathOperator{\Exp}{\mathsf{Exp}} \DeclareMathOperator{\Env}{\mathsf{Env}} \DeclareMathOperator{\Nf}{\mathsf{Nf}} \DeclareMathOperator{\Ne}{\mathsf{Ne}} \DeclareMathOperator{\nf}{\mathsf{nf}} \DeclareMathOperator{\ne}{\mathsf{ne}} \DeclareMathOperator{\var}{\mathsf{v}} \DeclareMathOperator{\xx}{\mathsf{x}} \DeclareMathOperator{\true}{\mathsf{true}} \DeclareMathOperator{\false}{\mathsf{false}} \DeclareMathOperator{\meaning}{\mathsf{meaning}} \newcommand{\vi}{\var_i} \newcommand{\pipe}{\,\mathbin{|}\,} \]</p>
</div>
<p>This is the first in a series of posts written in which I work through some topics in “real-world” implementation of type-theoretic concepts and the more “engineering”-like aspects of writing a theorem prover, inspired by András Kovács’s <a href="https://math.stackexchange.com/questions/3466976/online-reference-book-for-implementing-concepts-in-type-theory">MSE literature survey</a> on the topic. The eventual goal is to attain enough proficiency in both type theory and proof assistant engineering to be able to implement my own Idris-like language, but that’s probably far off. Still, it’s worth getting started earlier than not.</p>
<p>Please contact me about any errors or with any comments, either on <a href="https://twitter.com/mrkgrnao">Twitter</a>, or at <code>chow dot soham at gmail</code>.</p>
<h1 id="introduction">Introduction</h1>
<p>Consider some simple language, say the untyped <span class="math inline"><em>λ</em></span>-calculus with lets and booleans:</p>
<p>\[ e ::= x \mathbin{|} \lambda x. e \mathbin{|} e\,e \mathbin{|} \mathsf{let}\,x = e\,\mathsf{in}\,e \pipe \true \pipe \false \]</p>
<p>Syntactic expressions in this language look like <code>x</code>, <code>k (λx. λy. y)</code>, <code>λz. let id = λy. y in id (z true)</code>, and so on. Let us denote the set of all such expressions by \(\mathsf{Exp}\).</p>
<p>One of the most basic things we can do with an expression in a language like this is evaluate it. For our purposes, <strong>evaluation</strong> is the process of executing or running a program \(t\) in a language, transforming it into a <em>value</em>. To paraphrase <a href="http://www.cse.chalmers.se/~abela/habil.pdf">Abel</a>, the value that evaluation assigns to a program can reasonably be considered to be a way to assign a notion of “meaning” for the program. To that end, we might denote this value \(\meaning(t)\), and ask ourselves: what is a value? Put another way, where should our values live? It makes sense to clearly separate the language we are implementing – the <em>object</em> language – from the language we are implementing it <em>in</em> – the <em>meta</em>-language. To a compiler engineer, LLVM IR or x86 assembly are good things to which a program in a fancy language can be reduced. To a type theorist or a logician, it may be preferable to use set theory, exotic things like domains, or a mathematical presentation of a sufficiently powerful type theory (such as Martin-Löf type theory) as the metalanguage. For our purposes we will imagine ourselves as intrepid implementors of theorem provers, unconcerned with both theory and compilation for the time being, and content ourselves with Haskell types and values. For example, it would be satisfactory for us to be given the term <code>(λz. let id = λy. y in id true) false</code> and have it evaluate to some Haskell value <code>ExprTrue</code>, and subsequently pretty-print the string <code>true</code> to standard output. As long as we can make sense of the meaning, it’s fine, isn’t it?</p>
<p>Evaluation is closely related to, but not the same as, <strong>normalisation</strong>: the process of transforming an expression \(e \in\mathsf{Exp}\) into an expression \(e’\) contained in a subset \(\mathsf{Nf} \subseteq \mathsf{Exp}\). Expressions in \(\mathsf{Nf}\) are called <em>normal forms</em>, and \(e’\) is called the <em>normal form</em> of \(e\). It is important to note that normalisation is an operation where we start and end up at the same level, that of syntax, and can therefore be taken to be a purely syntactic operation.</p>
<h2 id="motivating-the-importance-of-normalisation">Motivating the importance of normalisation</h2>
<p>Why do we care about normalisation? Indeed, why are we interested in doing normalisation via evaluation as the title of this article tells us we’re going to look at doing?</p>
<p>Normalisation corresponds to a sensible notion of <em>computation</em> in most type systems; most theories with a natural number type, for example, will have terms like \(1 + 5\), \((1 + 1) * (1 + 1 + 1)\), and so on all reduce to \(6\). In Abel’s wonderful analogy, normalisation increases <em>entropy</em>, understood by analogy to thermodynamic entropy. In physics, entropy is a measure of <em>disorder</em> in a system. A pile of firewood contains a lot of complex organic molecules; lighting it on fire reduces it to much simpler molecules, reducing the total amount of “order” in the system, and converts some of the energy stored in chemical bonds to heat energy in the process. Energy is conserved, but the entropy of the (wood + oxygen + smoke + ashes) system increases in the process. In our PL-theoretic world, too, normalisation collapses — not chemical, but rather syntactic — structure.</p>
<p>Normalisation can intuitively be expected to satisfy certain properties which suggest its suitability as a notion of “computing the value of a complex expression”:</p>
<ul>
<li><p>in a typed language, normalising a term should not change its type: \[ \frac{\Gamma\vdash t : T}{\Gamma\vdash \nf(t) : T}\,\mathrm{\scriptsize{NF{-}WELL{-}TYPED}} \]</p></li>
<li><p>normalisation should be <em>idempotent</em>: \(\nf(t) = \nf(\nf(t)) \), and</p></li>
<li><p>normalisation should preserve the meaning of a term: \( \meaning(t) = \meaning(\nf(t)). \)</p></li>
</ul>
<p>So if you care about computing things inside some type theory, such as implementations of theorem provers or expressively-typed programming languages are required to do, normalisation is an important thing to think about.</p>
<p>Indeed, if you care about type-level computation, which is important to implementations of dependent type systems, the need for efficient normalisation becomes clear. Most dependent type theories have a rule in their typing judgments that looks something like</p>
<p>\[ \frac{\Gamma\vdash t : B\quad\quad\Gamma: A = B}{\Gamma\vdash t : A}\,\mathrm{\scriptsize{CONV}} \]</p>
<p>This says that if we want to show that a term \(t\) has type \(A\), it suffices to show it has type \(B\) for some other type \(B\), if we can also prove that \(A\) and \(B\) are <em>convertible</em>, which means “can be reduced to the same term”. In most type systems, this term is the normal form, so we can check for convertibility by normalising. For example, in a type theory with an “<span class="math inline"><em>η</em></span>-law for functions”, the terms \(t\) and \(\lambda x.t \, x\) both reduce to whatever \(t\) reduces to, and are hence convertible.</p>
<p>With all this said, it should be clear that for many type theories, typechecking involves applying that theory’s version of a \(\mathrm{\scriptsize{CONV}}\) rule many times, which usually reduces to a lot of normalisation, and hence to a lot of computations of normal forms. As our type systems increase in expressiveness, these computations become more and more complex; as <a href="http://davidchristiansen.dk/tutorials/implementing-types-hs.pdf">Christiansen</a> points out, in general, types in a dependently-typed language can contain entire programs that we have to run to perform type-checking!</p>
<p>Computing normal forms efficiently is important: and that’s exactly what “normalisation by evaluation” lets us do.</p>
<p>This post is literate Haskell, so we enable a few language extensions we’ll be using.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE StandaloneDeriving, UnicodeSyntax #-}</span></span></code></pre></div>
<h2 id="aside-notions-of-equality">Aside: notions of equality</h2>
<p>Convertibility also often coincides with (and is used as a synonym for) <em>judgmental equality</em>, which refers to a notion of equality that arises from a judgment that explicitly tells us how we can tell when two types are convertible. (In the typing rule above this judgment is written \(A = B\); you’ll also see \(\equiv\) used in a lot of places.) Another common term for the same thing is <em>definitional equality</em>, which literally means an equality that holds “by definition”. These forms of equality can be contrasted with <em>propositional equality</em>, which refers to a form of equality that is internal to the type theory, and about which we can prove things from within the theory itself. For example, we can define the following type to capture a form of propositional equality in Haskell (with the <code>GADTs</code> extension enabled), and very similar things can be written in Agda or Idris:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Eq</span> a b <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Eq</span> a a</span></code></pre></div>
<p>With this, you can actually write the function</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">magic ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eq</span> a b <span class="ot">-&gt;</span> b</span>
<span id="cb3-2"><a href="#cb3-2"></a>magic x e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="dt">Refl</span> <span class="ot">-&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="co">-- in the body of this pattern-match,</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co">-- GHC knows that `a` and `b` are the same</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    x</span></code></pre></div>
<p>or even prove simple theorems like “propositional equality is transitive”, assuming you have accepted the Curry-Howard correspondence into your heart:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">prop_eq_trans ::</span> <span class="dt">Eq</span> a b <span class="ot">-&gt;</span> <span class="dt">Eq</span> b c <span class="ot">-&gt;</span> <span class="dt">Eq</span> a c</span>
<span id="cb4-2"><a href="#cb4-2"></a>prop_eq_trans <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span></code></pre></div>
<h1 id="the-problem-with-normalisation-by-reduction">The problem with normalisation by reduction</h1>
<p>Let’s try to figure out our own algorithm, in a broad sense, for performing normalisation in a simple type theory (like our untyped <span class="math inline"><em>λ</em></span>-calculus from above). The obvious choice is to simply “interpret” or “compute” the value of the expression. This can be expressed more formally as “keep on <span class="math inline"><em>β</em></span>-reducing until you can’t do it anymore”, where <span class="math inline"><em>β</em></span>-reduction refers to rewriting an expression of the form “function of a variable, applied to an expression” – something that looks like \( (\lambda x. b) M\), which in the theory of programming languages is called a <em><span class="math inline"><em>β</em></span>-redex</em>, from <em><strong>red</strong>ucible <strong>ex</strong>pression</em> – by substituting the expression for the variable, which can be denoted in symbols as</p>
<p>\[ (\lambda x. M) E \overset{\beta}{\longrightarrow} M[x := E] \]</p>
<p>— in other words, the obvious thing that one might do with a function applied to something. For example,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">(</span>λx<span class="ot">.</span> λy<span class="ot">.</span> z x<span class="ot">)</span> <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">=</span> <span class="ot">(</span>λy<span class="ot">.</span> z <span class="dv">1</span><span class="ot">)</span> <span class="dv">2</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">=</span> z <span class="dv">1</span></span></code></pre></div>
<p>This process is called <em>reduction</em>, and the resulting way to do normalisation is called <em>normalisation by reduction</em>. In more complex type theories, there are many more rules than just <span class="math inline"><em>β</em></span>-reduction and <span class="math inline"><em>η</em></span>-expansion, all of which must be applied to perform normalisation.</p>
<p>Normalisation by reduction works, and for a simple-minded implementation of a typechecker (such as all the ones I’ve written in the past), there’s nothing wrong with it. The bad thing about using normalisation by reduction in a “production” typechecker, such as one you’d put in a theorem prover that real people use, is that explicit syntactic substitution involves a lot of manipulation of abstract syntax trees. Compared to the alternative that this post is about, this means that normalisation by reduction is usually <em>slower</em>, and it also happens to be quite tricky to implement.</p>
<p>Instead, we can construct a way to perform normalisation by taking advantage of efficient methods for <em>evaluation</em>.</p>
<h1 id="normalisation-by-evaluation-for-the-untyped-lambda-calculus">Normalisation by evaluation for the (untyped) <span class="math inline"><em>λ</em></span>-calculus</h1>
<p>We will illustrate normalisation by evaluation in an <em>untyped</em> setting, by using it to study the untyped <span class="math inline"><em>λ</em></span>-calculus in this article. NbE also has a typed variant, which is the one we’re actually interested in (we care about type systems with expressive, often dependent notions of typing, for the appropriate value of “we” *wink wink*). We’ll address typed NbE in a future post, but the simplicity of the untyped <span class="math inline"><em>λ</em></span>-calculus makes it an ideal setting in which to come to grips with how NbE works. (At least, it did for me.)</p>
<p>Recall from the opening of this article that our goal is to start with a syntactic expression of some type \(\Exp\) describing our syntax and end up with a normal form of type \(\Nf\), which describes the normal forms in our syntax. At a high level, the untyped NbE algorithm works by <em>interpreting</em>, <em>reflecting</em>, or <em>evaluating</em> our syntax \(\Exp\) into a <em>semantic domain</em> \(\D\), then <em>reifying</em> or <em>quoting</em> the semantic value back into the normal-form subset \(\Nf\) of our syntax.</p>
<h2 id="background-de-bruijn-indices-and-levels">Background: De Bruijn indices and levels</h2>
<p>De Bruijn indices are a tool used to describe variable binding that provide a lot of convenience both for theoretical purposes and for someone implementing a language using them, compared to describing bindings using, say, variable name-based (<em>named</em>) representations. Using (0-based) De Bruijn indices, the “S combinator” – \[\lambda x.\lambda y.\lambda z. x z (y z)\] – would be written <code>λ λ λ 2 0 (1 0)</code>. The number \(n\) refers to how many <span class="math inline"><em>λ</em></span>s are in between the variable and its binding site: the most recently bound variable is <code>0</code>, the one bound before that is <code>1</code>, and so on.</p>
<p>De Bruijn levels are similar, and in some sense arise from the “opposite” or “dual” convention, in which the number \(n\) refers to the \(n\)th lambda from the beginning. In this notation, the S combinator would be written <code>λ λ λ 0 2 (1 2)</code>.</p>
<p>It should be clear how to convert between DB-indices and -levels if one considers the problem for a little while. Abel depicts the relation between them in an expression with \(n\) lambdas as follows:</p>
<p>\begin{alignat*}{10} \text{index}\quad &amp;0\quad &amp;&amp;1\quad &amp;&amp;\ldots\quad &amp;&amp;k\quad &amp;&amp;\ldots\quad &amp;&amp;n-i-1\quad &amp;&amp;\ldots\quad &amp;&amp;n-2\quad &amp;&amp;n-1\\ \text{level}\quad &amp;n-1\quad &amp;&amp;n-2\quad &amp;&amp;\ldots\quad &amp;&amp;n-k-1\quad &amp;&amp;\ldots\quad &amp;&amp;i\quad &amp;&amp;\ldots\quad &amp;&amp;1\quad &amp;&amp;0 \end{alignat*}</p>
<h2 id="implementing-nbe-for-the-untyped-lambda-calculus">Implementing NbE for the untyped <span class="math inline"><em>λ</em></span>-calculus</h2>
<p>We define the grammar that specifies the syntax of untyped LC itself below. In addition, we also define two additional grammars that specify the syntax of two subclasses of terms, called <em>neutral</em> terms and <em>normal</em> terms.</p>
<p>\begin{alignat*}{4} \text{expressions} \quad &amp;\Exp &amp;&amp;\ni r, s, t \quad &amp;&amp;::=\quad \vi \pipe \lambda t \pipe r\,s \\ \text{neutral terms} \quad &amp;\Ne &amp;&amp;\ni u \quad &amp;&amp;::=\quad \vi \pipe u\,v \\ \text{normal terms} \quad &amp;\Nf &amp;&amp;\ni v \quad &amp;&amp;::=\quad u \pipe \lambda v \end{alignat*}</p>
<p>Neutral terms are normal terms that are “blocked” or “stuck”, either because some variable has an unknown value (the term is <em>open</em>), or we are trying to apply something to a value but cannot realise our “something” as a function (in other words, we cannot <span class="math inline"><em>β</em></span>-reduce or perform “substitution”). This property of neutral terms is immediate from the above definitions. Indeed, in defining neutral and normal terms, we’ve cleverly divided up the three elements of the grammar of expressions – variables, abstractions, and application — in such a way that normal and neutral terms are forced to be <span class="math inline"><em>β</em></span>-normal. (A term is <span class="math inline"><em>β</em></span>-normal if it contains no <span class="math inline"><em>β</em></span>-redexes, that is, if no further <span class="math inline"><em>β</em></span>-reduction is possible.) We see that our application form \(u\,v\) can only apply a neutral term to something, and neutrals cannot contain or be <span class="math inline"><em>λ</em></span>-abstractions, as is obvious from the grammar. Similarly, normal terms are where all the lambdas end up residing, but they offer us no way to <em>apply</em> anything to a <span class="math inline"><em>λ</em></span>-abstraction.</p>
<p>We represent the <em>syntactic domain</em> (which is what we’ll call the (original) “object language” above that captures the <em>syntax</em> of the untyped <span class="math inline"><em>λ</em></span>-calculus) in Haskell as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Exp</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">&gt;</span>   <span class="ot">=</span> <span class="dt">ExpVar</span> <span class="dt">Int</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">&gt;</span>   <span class="op">|</span> <span class="dt">ExpLam</span> <span class="dt">Exp</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">&gt;</span>   <span class="op">|</span> <span class="dt">ExpApp</span> <span class="dt">Exp</span> <span class="dt">Exp</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ot">&gt;</span> </span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Ne</span> <span class="ot">=</span> <span class="dt">NeVar</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">NeApp</span> <span class="dt">Ne</span> <span class="dt">Nf</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ot">&gt;</span> </span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Nf</span> <span class="ot">=</span> <span class="dt">NfNeut</span> <span class="dt">Ne</span> <span class="op">|</span> <span class="dt">NfLam</span> <span class="dt">Nf</span></span></code></pre></div>
<p>The <em>semantic domain</em>, which is the collection of grammars capturing “meaning” (or the “modified object language” that we interpret the object language <em>into</em>, if you prefer), looks like this:</p>
<p>\begin{alignat*}{3} \text{environments} \quad&amp;\Env &amp;&amp;\ni \rho \quad &amp;&amp;::=\quad\text{functions}\,\, \mathbb{N}\to \D\\ \text{} \quad &amp;\D &amp;&amp;\ni d \quad &amp;&amp;::=\quad (\underline{\lambda} t) \rho \pipe e \\ \text{\(\D\) extended with neutrals} \quad &amp;\Dne &amp;&amp;\ni e \quad &amp;&amp;::= \quad \xx_k \pipe e\, d \end{alignat*}</p>
<p>Semantic terms \(\xx_k\) represent variables, but unlike the \(\var_k\) variables from the syntactic setup, they do so using De Bruijn <em>levels</em> instead of indices. This is because semantic terms refer to “absolute” variables (TODO how?) that are akin to constants, rather than index-like references whose meaning is context-dependent. According to Abel, this design decision frees us from considering complications like having to build some notion of context shifting into the theory of the semantic domain or evaluation-quotation itself.</p>
<p>We translate the semantic domain into code in terms of the following types. First, an environment (also often called a <em>context</em>) is a mapping of De Bruijn indices (hence variables) to semantic terms (values):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span></code></pre></div>
<p>Semantic terms are either closures containing a syntactic term and an environment in which to make sense of it, or stuck semantic terms – semantic <em>neutrals</em> represented using the type <code>Dne</code> – that we can’t reduce any further.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">D</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">&gt;</span>   <span class="ot">=</span> <span class="dt">Clos</span> <span class="dt">Exp</span> <span class="dt">Env</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ot">&gt;</span>   <span class="op">|</span> <span class="dt">Up</span> <span class="dt">Dne</span></span></code></pre></div>
<p>Note how <code>D</code> values built using the <code>Clos</code> constructor contain environments represented as native Haskell functions.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Dne</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">&gt;</span>   <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">&gt;</span>   <span class="op">|</span> <span class="dt">App</span> <span class="dt">Dne</span> <span class="dt">D</span></span></code></pre></div>
<p>Next we have a “context shifting” operation called <code>update</code>, which can be thought of as pushing us one <span class="math inline"><em>λ</em></span>-binder deeper: it binds \(\var_0\) to <code>d</code> and updates the rest of the context to match. Notice how this function, in a naive presentation of normalisation by reduction, would have to be implemented by manipulating a data structure like a list or a map.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">&gt; update ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Env</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">&gt;</span> update rho d <span class="dv">0</span> <span class="ot">=</span> d</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="ot">&gt;</span> update rho d i <span class="ot">=</span> rho (i <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>We have two mutually recursive functions that help us go from syntax to semantics: given an environment assigning meanings to variables, <code>eval</code> interprets an syntactic expression into the semantic domain, giving us a semantic term, aided by <code>apply</code>, which performs function application (substitution!) in the semantic domain.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">&gt; eval ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">&gt;</span> eval e rho <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="ot">&gt;</span> </span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="ot">&gt;</span>   <span class="co">-- look it up in the environment</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="ot">&gt;</span>   <span class="dt">ExpVar</span> i   <span class="ot">-&gt;</span> rho i</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="ot">&gt;</span> </span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="ot">&gt;</span>   <span class="co">-- store the body of the lambda in a closure, together with the environment</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="ot">&gt;</span>   <span class="co">-- we saw it in</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="ot">&gt;</span>   <span class="dt">ExpLam</span> t   <span class="ot">-&gt;</span> <span class="dt">Clos</span> t rho</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="ot">&gt;</span> </span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="ot">&gt;</span>   <span class="co">-- interpret the function and the argument, and then substitute (efficiently!)</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="ot">&gt;</span>   <span class="dt">ExpApp</span> r s <span class="ot">-&gt;</span> apply (eval r rho) (eval s rho)</span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="ot">&gt;</span> </span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="ot">&gt; apply ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="ot">&gt;</span> apply (<span class="dt">Clos</span> t rho) d <span class="ot">=</span> eval t (update rho d)</span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="ot">&gt;</span> apply (<span class="dt">Up</span> e)       d <span class="ot">=</span> <span class="dt">Up</span> (<span class="dt">App</span> e d)</span></code></pre></div>
<p><code>quoteNf</code> and <code>quoteNe</code> perform <em>quotation</em>, or <em>read-back</em> in Abel’s terminology, of semantic terms back into the syntactic domain. The only interesting case is the <code>Clos</code> clause in <code>quoteNf</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">&gt; quoteNf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Nf</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">&gt;</span> quoteNf n (<span class="dt">Clos</span> t rho) <span class="ot">=</span> <span class="dt">NfLam</span> (quoteNf (n <span class="op">+</span> <span class="dv">1</span>) b)</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="ot">&gt;</span>   <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">&gt;</span>     <span class="co">-- after &quot;entering&quot; a new binder using the update function,</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="ot">&gt;</span>     <span class="co">-- using a &quot;fresh&quot; variable,</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="ot">&gt;</span>     rho' <span class="ot">=</span> update rho (<span class="dt">Up</span> (<span class="dt">Var</span> n))</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="ot">&gt;</span>     <span class="co">-- evaluate the body of the lambda on the new, innermost variable</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="ot">&gt;</span>     <span class="co">-- (remember that the semantic domain uses DB-levels)</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="ot">&gt;</span>     b <span class="ot">=</span> eval t rho'</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="ot">&gt;</span> quoteNf n (<span class="dt">Up</span> e) <span class="ot">=</span> <span class="dt">NfNeut</span> (quoteNe n e)</span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="ot">&gt;</span> </span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="ot">&gt; quoteNe ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Dne</span> <span class="ot">-&gt;</span> <span class="dt">Ne</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="ot">&gt;</span> quoteNe n (<span class="dt">Var</span> k)   <span class="ot">=</span> <span class="dt">NeVar</span> (n <span class="op">-</span> k <span class="op">-</span> <span class="dv">1</span>) <span class="co">-- DB-level to -index</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="ot">&gt;</span> quoteNe n (<span class="dt">App</span> e d) <span class="ot">=</span> <span class="dt">NeApp</span> (quoteNe n e) (quoteNf n d)</span></code></pre></div>
<p>Finally, normalisation is performed by first evaluating syntactic terms into the semantic domain, and then quoting the result back to give us a normal form.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">&gt;</span> <span class="co">-- | Compute the normal form of an open term with at most `n` free variables.</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">&gt; nfOpen ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Nf</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="ot">&gt;</span> nfOpen n t <span class="ot">=</span> quoteNf n (eval t rho)</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="ot">&gt;</span>   <span class="kw">where</span> rho i <span class="ot">=</span> <span class="dt">Up</span> (<span class="dt">Var</span> (n <span class="op">-</span> i <span class="op">-</span> <span class="dv">1</span>)) <span class="co">-- DB-index to -level</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="ot">&gt;</span> </span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="ot">&gt;</span> <span class="co">-- | Compute the normal form of a closed term.</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="ot">&gt; nf ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Nf</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="ot">&gt;</span> nf <span class="ot">=</span> nfOpen <span class="dv">0</span></span></code></pre></div>
<p>As a sanity check, we define the SKI combinators…</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">&gt;</span> expI <span class="ot">=</span> <span class="dt">ExpLam</span> (<span class="dt">ExpVar</span> <span class="dv">0</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="ot">&gt;</span> </span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="ot">&gt;</span> expSKK <span class="ot">=</span> <span class="dt">ExpApp</span> (<span class="dt">ExpApp</span> expS expK) expK</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="ot">&gt;</span>   <span class="kw">where</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ot">&gt;</span>     <span class="co">-- λ 0</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="ot">&gt;</span>     expI <span class="ot">=</span> <span class="dt">ExpLam</span> (<span class="dt">ExpVar</span> <span class="dv">0</span>)</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="ot">&gt;</span>     <span class="co">-- λ λ 1</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="ot">&gt;</span>     expK <span class="ot">=</span> <span class="dt">ExpLam</span> (<span class="dt">ExpLam</span> (<span class="dt">ExpVar</span> <span class="dv">1</span>))</span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="ot">&gt;</span>     <span class="co">-- λ λ λ 2 0 (1 0)</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="ot">&gt;</span>     expS</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="ot">&gt;</span>       <span class="ot">=</span> <span class="dt">ExpLam</span> (<span class="dt">ExpLam</span> (<span class="dt">ExpLam</span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="ot">&gt;</span>           (<span class="dt">ExpApp</span> (<span class="dt">ExpApp</span> (<span class="dt">ExpVar</span> <span class="dv">2</span>) (<span class="dt">ExpVar</span> <span class="dv">0</span>))</span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="ot">&gt;</span>                    (<span class="dt">ExpApp</span> (<span class="dt">ExpVar</span> <span class="dv">1</span>) (<span class="dt">ExpVar</span> <span class="dv">0</span>)))))</span></code></pre></div>
<p>… and confirm that <code>SKK = I</code> when defined in terms of the lambda-calculus:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell-eval code-eval haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>λ<span class="op">&gt;</span> nf expSKK</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="dt">NfLam</span> (<span class="dt">NfNeut</span> (<span class="dt">NeVar</span> <span class="dv">0</span>))</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell-eval code-eval haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>λ<span class="op">&gt;</span> nf expSKK <span class="op">==</span> nf expI</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="dt">True</span></span></code></pre></div>
<h2 id="a-pragmatic-variation-on-the-textbook-implementation">A “pragmatic” variation on the textbook implementation</h2>
<p>It is possible to entirely mechanically combine <code>D</code> and <code>Dne</code> (into a <code>Val</code> type), by “inlining” the constructors for neutrals into the datatypes for normal forms. This makes some illegal states representable — for example, you can represent <span class="math inline"><em>β</em></span>-redexes in the semantic domain, which is kind of iffy — but has the advantage of reducing a bit of indirection and improving performance, and also just reducing the amount of code that we have to work with.</p>
<p>Let’s use a superscript C to denote the pieces of this new “collapsed” implementation. First, we can get rid of <code>Up</code> and <code>NfNeut</code>, which were just wrappers to bring neutrals into normal terms and values:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Exp</span>ᶜ <span class="ot">=</span> <span class="dt">ExpVar</span>ᶜ <span class="dt">Int</span> <span class="op">|</span> <span class="dt">ExpLam</span>ᶜ  <span class="dt">Exp</span>ᶜ      <span class="op">|</span> <span class="dt">ExpApp</span>ᶜ <span class="dt">Exp</span>ᶜ <span class="dt">Exp</span>ᶜ</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Val</span>ᶜ <span class="ot">=</span> <span class="dt">ValVar</span>ᶜ <span class="dt">Int</span> <span class="op">|</span> <span class="dt">ValClos</span>ᶜ <span class="dt">Exp</span>ᶜ <span class="dt">Env</span>ᶜ <span class="op">|</span> <span class="dt">ValApp</span>ᶜ <span class="dt">Val</span>ᶜ <span class="dt">Val</span>ᶜ</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Env</span>ᶜ <span class="ot">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Val</span>ᶜ</span></code></pre></div>
<p>and the code for the old <code>apply</code> can be “inlined” into that of <code>eval</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">&gt;</span> updateᶜ<span class="ot"> ::</span> <span class="dt">Env</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Val</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Env</span>ᶜ</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="ot">&gt;</span> updateᶜ rho d <span class="dv">0</span> <span class="ot">=</span> d</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="ot">&gt;</span> updateᶜ rho d i <span class="ot">=</span> rho (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="ot">&gt;</span> </span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="ot">&gt;</span> evalᶜ<span class="ot"> ::</span> <span class="dt">Exp</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Env</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Val</span>ᶜ</span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="ot">&gt;</span> evalᶜ e rho <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="ot">&gt;</span>   <span class="dt">ExpVar</span>ᶜ i   <span class="ot">-&gt;</span> rho i</span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="ot">&gt;</span>   <span class="dt">ExpLam</span>ᶜ t   <span class="ot">-&gt;</span> <span class="dt">ValClos</span>ᶜ t rho</span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="ot">&gt;</span>   <span class="dt">ExpApp</span>ᶜ r s <span class="ot">-&gt;</span> <span class="kw">case</span> (evalᶜ r rho, evalᶜ s rho) <span class="kw">of</span></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="ot">&gt;</span>     (<span class="dt">ValClos</span>ᶜ t rho, d) <span class="ot">-&gt;</span> evalᶜ t (updateᶜ rho d)</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="ot">&gt;</span>     (e,              d) <span class="ot">-&gt;</span> <span class="dt">ValApp</span>ᶜ e d</span></code></pre></div>
<p>If we proceed as above for quotation too, we can combine <code>Nf</code> and <code>Ne</code>, and there would only be one <code>quoteᶜ</code> function (performing quotation to normal forms: our old <code>quoteNf</code>), with <code>quoteNe</code> inlined into <code>quoteᶜ</code> where the <code>Up</code> case was. It should be clear that collapsing neutrals into the type of normal forms gives us a type that is isomorphic to <code>Expᶜ</code>, so we can go even further and just identify the two, quoting back into the original syntactic domain:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">&gt;</span> quoteᶜ<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Val</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Exp</span>ᶜ</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ot">&gt;</span> quoteᶜ n (<span class="dt">ValVar</span>ᶜ k)      <span class="ot">=</span> <span class="dt">ExpVar</span>ᶜ (n <span class="op">-</span> k <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="ot">&gt;</span> quoteᶜ n (<span class="dt">ValApp</span>ᶜ e d)    <span class="ot">=</span> <span class="dt">ExpApp</span>ᶜ (quoteᶜ n e) (quoteᶜ n d)</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="ot">&gt;</span> quoteᶜ n (<span class="dt">ValClos</span>ᶜ t rho) <span class="ot">=</span> <span class="dt">ExpLam</span>ᶜ (quoteᶜ (n <span class="op">+</span> <span class="dv">1</span>) b)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="ot">&gt;</span>   <span class="kw">where</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="ot">&gt;</span>     rho' <span class="ot">=</span> updateᶜ rho (<span class="dt">ValVar</span>ᶜ n)</span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="ot">&gt;</span>     b <span class="ot">=</span> evalᶜ t rho'</span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="ot">&gt;</span> </span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="ot">&gt;</span> nfOpenᶜ<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Exp</span>ᶜ</span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="ot">&gt;</span> nfOpenᶜ n t <span class="ot">=</span> quoteᶜ n (evalᶜ t rho)</span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="ot">&gt;</span>   <span class="kw">where</span> rho i <span class="ot">=</span> <span class="dt">ValVar</span>ᶜ (n <span class="op">-</span> i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="ot">&gt;</span> </span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="ot">&gt;</span> nfᶜ<span class="ot"> ::</span> <span class="dt">Exp</span>ᶜ <span class="ot">-&gt;</span> <span class="dt">Exp</span>ᶜ</span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="ot">&gt;</span> nfᶜ <span class="ot">=</span> nfOpenᶜ <span class="dv">0</span></span></code></pre></div>
<p>We can repeat our SKI combinator check from before. (I’ve put the definitions at the end of the article to reduce clutter.)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell-eval code-eval haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>λ<span class="op">&gt;</span> nfᶜ expSKKᶜ</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpVar</span>ᶜ <span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell-eval code-eval haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a>λ<span class="op">&gt;</span> nfᶜ expSKKᶜ <span class="op">==</span> expIᶜ</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="dt">True</span></span></code></pre></div>
<p>If you squint, except for the fact that we use a nameless (De Bruijn) representation instead of his explicitly named representation, this is almost the same as <a href="https://github.com/AndrasKovacs/elaboration-zoo/blob/master/01-eval/Main.hs">András’s implementation</a> of untyped NbE for the <span class="math inline"><em>λ</em></span>-calculus! And he <em>really</em> knows what he’s doing, so I’ll call that a job well done.</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>All the code is implemented from, and most of the ideas and information come from, chapters 2 and 3 of <a href="http://www.cse.chalmers.se/~abela/habil.pdf">Andreas Abel’s habilitation thesis</a>, and to some extent can be said to be the output I generated while working through them trying to internalise why everything “really” works. It’s quite readable, and I greatly recommend reading it if you enjoyed this.</p>
<p>Thanks to <a href="https://twitter.com/brendanzab/">Brendan</a> for getting me interested in NbE in the first place, and to <a href="https://twitter.com/andrasKovacs6">András</a> for his help and for writing the <a href="https://math.stackexchange.com/questions/3466976/online-reference-book-for-implementing-concepts-in-type-theory">literature review</a> and the <a href="https://github.com/AndrasKovacs/elaboration-zoo/">Elaboration Zoo</a>.</p>
<h2 id="odds-and-ends">Odds and ends</h2>
<p>I prefer putting derived instances at the end to help streamline the main presentation a little. (Every bit helps; I barely understand this material as is!)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Exp</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Nf</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Ne</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ot">&gt;</span> </span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Exp</span></span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Nf</span></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Ne</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="ot">&gt;</span> </span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Exp</span>ᶜ</span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="ot">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Exp</span>ᶜ</span></code></pre></div>
<p>I should really have used a tagless-final representation to avoid rewriting these… on second thought, maybe not.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literatehaskell literate"><code class="sourceCode literatehaskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">&gt;</span> expIᶜ <span class="ot">=</span> <span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpVar</span>ᶜ <span class="dv">0</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="ot">&gt;</span> </span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="ot">&gt;</span> expSKKᶜ <span class="ot">=</span> <span class="dt">ExpApp</span>ᶜ (<span class="dt">ExpApp</span>ᶜ expS expK) expK</span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="ot">&gt;</span>   <span class="kw">where</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="ot">&gt;</span>     <span class="co">-- λ 0</span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="ot">&gt;</span>     expI <span class="ot">=</span> <span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpVar</span>ᶜ <span class="dv">0</span>)</span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="ot">&gt;</span>     <span class="co">-- λ λ 1</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="ot">&gt;</span>     expK <span class="ot">=</span> <span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpVar</span>ᶜ <span class="dv">1</span>))</span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="ot">&gt;</span>     <span class="co">-- λ λ λ 2 0 (1 0)</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="ot">&gt;</span>     expS</span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="ot">&gt;</span>       <span class="ot">=</span> <span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpLam</span>ᶜ (<span class="dt">ExpLam</span>ᶜ</span>
<span id="cb23-12"><a href="#cb23-12"></a><span class="ot">&gt;</span>           (<span class="dt">ExpApp</span>ᶜ (<span class="dt">ExpApp</span>ᶜ (<span class="dt">ExpVar</span>ᶜ <span class="dv">2</span>) (<span class="dt">ExpVar</span>ᶜ <span class="dv">0</span>))</span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="ot">&gt;</span>                    (<span class="dt">ExpApp</span>ᶜ (<span class="dt">ExpVar</span>ᶜ <span class="dv">1</span>) (<span class="dt">ExpVar</span>ᶜ <span class="dv">0</span>)))))</span></code></pre></div></section></article>
</main><footer class="page-footer"><a href="https://github.com/mrkgnao/mikrokosmos">Source</a> / <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a></footer></body></html>
